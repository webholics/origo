<?php
/**
* Origo - social client
* ApiController
*
* @copyright Copyright (c) 2008-2009 Mario Volke
* @author    Mario Volke <mario.volke@webholics.de>
*/

class ApiController extends BaseController
{
	/**
	 * The maximum number of seeAlso references to load per profile.
	 */
	protected $_maxSeeAlso = 10;
	 
	/**
	 * Only the properties in this array are allowed to be set via the api
	 */
	protected $_properties = array(
		'title' 				=> array('http://xmlns.com/foaf/0.1/title', 			'literal'),
		'nick' 					=> array('http://xmlns.com/foaf/0.1/nick', 				'literal'),
		'homepage' 				=> array('http://xmlns.com/foaf/0.1/homepage',			'uri'),
		'mbox' 					=> array('http://xmlns.com/foaf/0.1/mbox', 				'uri'),
		'mbox_sha1sum' 			=> array('http://xmlns.com/foaf/0.1/mbox_sha1sum', 		'literal'),
		'phone'		 			=> array('http://xmlns.com/foaf/0.1/phone', 			'uri'),
		'img' 					=> array('http://xmlns.com/foaf/0.1/img', 				'uri'),
		'depiction'				=> array('http://xmlns.com/foaf/0.1/depiction', 		'uri'),
		'family_name' 			=> array('http://xmlns.com/foaf/0.1/family_name', 		'literal'),
		'givenname' 			=> array('http://xmlns.com/foaf/0.1/givenname', 		'literal'),
		'name'					=> array('http://xmlns.com/foaf/0.1/name', 				'literal'),
		'weblog' 				=> array('http://xmlns.com/foaf/0.1/weblog', 			'uri'),
		'workinfohomepage' 		=> array('http://xmlns.com/foaf/0.1/workInfoHomepage', 	'uri'),
		'workplacehomepage' 	=> array('http://xmlns.com/foaf/0.1/workplaceHomepage',	'uri'),
		'schoolhomepage' 		=> array('http://xmlns.com/foaf/0.1/schoolHomepage',	'uri'),
		'plan' 					=> array('http://xmlns.com/foaf/0.1/plan', 				'uri'),
		'geekcode' 				=> array('http://xmlns.com/foaf/0.1/geekcode', 			'literal'),
		'gender' 				=> array('http://xmlns.com/foaf/0.1/gender', 			'literal'),
		'myersbriggs' 			=> array('http://xmlns.com/foaf/0.1/myersBriggs', 		'literal'),
		'openid' 				=> array('http://xmlns.com/foaf/0.1/openid', 			'uri'),
		'icq' 					=> array('http://xmlns.com/foaf/0.1/icqChatID', 		'literal'),
		'msn' 					=> array('http://xmlns.com/foaf/0.1/msnChatID', 		'literal'),
		'aim' 					=> array('http://xmlns.com/foaf/0.1/aimChatID', 		'literal'),
		'yahoo' 				=> array('http://xmlns.com/foaf/0.1/yahooChatID', 		'literal'),
		'jabber' 				=> array('http://xmlns.com/foaf/0.1/jabberID', 			'literal'),
	);

	/**
	 * propertyToShortcut
	 * This array accelerates some computations and
	 * will be autogenerated in init().
	 */
	 protected $_propertyToShortcut;

	/**
	 * Possible relationships
	 */
	protected $_relationships = array(
		'knows' => 'http://xmlns.com/foaf/0.1/knows',
		'acquaintanceof' => 'http://purl.org/vocab/relationship/acquaintanceOf',
		'ambivalentof' => 'http://purl.org/vocab/relationship/ambivalentOf',
		'ancestorof' => 'http://purl.org/vocab/relationship/ancestorOf',
		'antagonistof' => 'http://purl.org/vocab/relationship/antagonistOf',
		'apprenticeto' => 'http://purl.org/vocab/relationship/apprenticeTo',
		'childof' => 'http://purl.org/vocab/relationship/childOf',
		'closefriendof' => 'http://purl.org/vocab/relationship/closeFriendOf',
		'collaborateswith' => 'http://purl.org/vocab/relationship/collaboratesWith',
		'colleagueof' => 'http://purl.org/vocab/relationship/colleagueOf',	
		'descendantof' => 'http://purl.org/vocab/relationship/descendantOf',
		'employedby' => 'http://purl.org/vocab/relationship/employedBy',	
		'employerof' => 'http://purl.org/vocab/relationship/employerOf',
		'enemyof' => 'http://purl.org/vocab/relationship/enemyOf',
		'engagedto' => 'http://purl.org/vocab/relationship/engagedTo',	
		'friendof' => 'http://purl.org/vocab/relationship/friendOf',	
		'grandchildof' => 'http://purl.org/vocab/relationship/grandchildOf',
		'grandparentof' => 'http://purl.org/vocab/relationship/grandparentOf',
		'hasmet' => 'http://purl.org/vocab/relationship/hasMet',
		'knowsbyreputation' => 'http://purl.org/vocab/relationship/knowsByReputation',
		'knowsinpassing' => 'http://purl.org/vocab/relationship/knowsInPassing',
		'knowsof' => 'http://purl.org/vocab/relationship/knowsOf',
		'lifepartnerof' => 'http://purl.org/vocab/relationship/lifePartnerOf',
		'liveswith' => 'http://purl.org/vocab/relationship/livesWith',	
		'lostcontactwith' => 'http://purl.org/vocab/relationship/lostContactWith',
		'mentorof' => 'http://purl.org/vocab/relationship/mentorOf',	
		'neighborof' => 'http://purl.org/vocab/relationship/neighborOf',	
		'parentof' => 'http://purl.org/vocab/relationship/parentOf',	
		'participantin' => 'http://purl.org/vocab/relationship/participantIn',
		'siblingof' => 'http://purl.org/vocab/relationship/siblingOf',	
		'spouseof' => 'http://purl.org/vocab/relationship/spouseOf',	
		'workswith' => 'http://purl.org/vocab/relationship/worksWith',	
		'wouldliketoknow' => 'http://purl.org/vocab/relationship/wouldLikeToKnow',
	);	

	public function init()
	{
		parent::init();
		$this->_helper->viewRenderer->setNoRender();

		foreach($this->_properties as $key => $value) {
			$this->_propertyToShortcut[$value[0]] = $key;
		}
	}

	public function preDispatch() 
	{	
		// force authentication for all api methods
		// except for error
		$request = $this->getRequest();
		if($request->getControllerName() != 'api' || $request->getActionName() != 'error') {
			if(!$this->authenticate()) {
				$this->_forward('error', 'api', null, array(
					//'http_code' => 401, Flex/ASÂ§ doesn't support status codes
					'code' => 'AuthenticationFailed',
					'message' => 'Authentication failed!'
				));
			}
		}
	}

	/**
	 * Error Action
	 */
	public function errorAction()
	{
		$code = $this->getRequest()->getParam('code');
		$http_code = $this->getRequest()->getParam('http_code');
		$message = $this->getRequest()->getParam('message');

		if(!empty($http_code))
			$this->getResponse()->setHttpResponseCode($http_code);
		
		$xml = 
			'<error>' .
				'<error_code>' . $code . '</error_code>' .
				'<error_message>' . $message . '</error_message>' .
			'</error>';

		$this->outputXml($xml);
	}

	/**
	 * Test Action
	 * Use this action to test authentication and status of the api.
	 */
	public function testAction()
	{
		$this->outputXml('
			<result>
				<code>200</code>
				<message>API status: OK</message>
			</result>
		');
	}

	/**
	 * Escape values for triple store queries.
	 *
	 * @param string $value The value to escape.
	 * @param string $type (uri|literal)
	 * @return string
	 */
	protected function escape($value, $type='literal') 
	{
		switch($type) {
			case 'uri':
				$value = str_replace(array('<', '>'), array('%3C', '%3E'), $value);
			default:
				$value = str_replace('"', '""', $value);
		}

		return $value;
	}

	/**
	 * Output XML
	 * and set correct header.
	 * 
	 * @param string|SimpleXMLElement $xml 
	 * @return void
	 */
	protected function outputXml($xml)
	{
		$response = $this->getResponse();
		$response->setHeader('Content-Type', 'application/xml');

		if($xml instanceof SimpleXMLElement)
			$response->appendBody($xml->asXML());
		else {
			$xml = trim($xml);
			if(substr($xml, 0, 5) != '<?xml')
				$xml = '<?xml version="1.0" encoding="UTF-8" ?>' . $xml;

			$response->appendBody($xml);
		}
	}
	
	/**
	 * Authentication
	 * Every api method which needs authentication
	 * has to provide a key (POST) parameter with value
	 * md5(username:password)
	 * 
	 * @return bool True if user is authenticated, false otherwise.
	 */
	protected function authenticate()
	{
		$config = $this->getConfig();

		if(empty($config->api->auth->username) && empty($config->api->auth->password))
			return true;

		$key = $this->getRequest()->getPost('key');
		$serviceKey = md5($config->api->auth->username . ':' . $config->api->auth->password);
		if($key && $key == $serviceKey)
			return true;

		return false;
	}

	/**
	 * Get profile by id.
	 * The profile has to be already loaded into the triple store.
	 *
	 * @param string $id bnode or uri identifier
	 * @param ARC2_Store $store The triple store to use
	 * @return string|false Profile as XML or false if error occured.
	 */
	protected function getProfile($id, $store) 
	{
		$xml = '';

		$query = $this->_queryPrefix .
			'SELECT ?key ?val WHERE {' .
				'<' . $id . '> ?key ?val .' .
			'}';
		$rows = $store->query($query, 'rows');

		if($errors = $store->getErrors()) {
			$this->forwardTripleStoreError($errors);
			return false;
		}

		$xml .= '<profile';

		// check if id is a bnode
		if(substr($id, 0, 2) == '_:') {
			// here comes a little hack:
			// some foaf profiles are only linked via rdfs:seeAlso
			// and assume foaf:primaryTopic to be set in the linked profile
			// therefore we search here for rdfs:seeAlso 
			// and link to the foaf document itself if found
			foreach($rows as $row) {
				if($row['key'] == 'http://www.w3.org/2000/01/rdf-schema#seeAlso') {
					$xml .= ' id="' . $row['val'] . '"';
					break;
				}
			}
		}
		else 
			$xml .= ' id="' . $id . '"';

		$xml .= '>';

		foreach($rows as $row) {
			if(isset($this->_propertyToShortcut[$row['key']])) {
				$key = $this->_propertyToShortcut[$row['key']];
				// some properties need special attention
				if($key == 'mbox')
					$row['val'] = substr($row['val'], 7);
				if($key == 'phone')
					$row['val'] = substr($row['val'], 4);
		
				$xml .= '<property name="' . $key . '">' . $row['val'] . '</property>';
			}
		}
	
		$xml .= '</profile>';

		return $xml;
	}

	/**
	 * Get external profiles of $id.
	 *
	 * @param string $id bnode or uri identifier
	 * @param ARC2_Store $store The triple store to use
	 * @return string|false Profiles as XML if an error occured.
	 */
	protected function getProfiles($id, $store)
	{
		$xml = '';
		
		$query = $this->_queryPrefix .
			'SELECT ?label ?sameas ?seealso WHERE {' .
				'<' . $id . '> owl:sameAs ?sameas . ' .
				'?sameas rdfs:seeAlso ?seealso .' .
				'OPTIONAL { ?sameas rdfs:label ?label . }' .
			'}';
		$rows = $store->query($query, 'rows');
		if($errors = $store->getErrors()) {
			$this->forwardTripleStoreError($errors);
			return false;
		}

		foreach($rows as $row) {
			$xml .= '<profile sameas="' . $row['sameas'] . '" seealso="' . $row['seealso'] . '"';

			if(isset($row['label']) && !empty($row['label']))
				$xml .= ' label="' . htmlentities($row['label'], ENT_COMPAT, 'UTF-8') . '"';

			$xml .= '/>';
		}

		return $xml;
	}

	/**
	 * Load URI.
	 * Can load a profile URI and a foaf:Person if URI is dereferencable.
	 * The methods checks if profile is already in triple store.
	 *
	 * @param string $uri The uri to load.
	 * @param bool $forwardError Forward to error if true.
	 * @return string|false Uri pointing to foaf:Person, or false if not found.
	 */
	protected function loadUri($uri, $forwardError=true) 
	{
		$loaded = false;
		$store = $this->getBrowserStore();

		// check if profile is already in triple store
		$ask = $this->_queryPrefix .
			'ASK WHERE {' .
				'{ <' . $uri . '> rdf:type foaf:PersonalProfileDocument }' .
				' UNION ' .
				'{ <' . $uri . '> rdf:type foaf:Person }' .
			'}';
		if(!$store->query($ask, 'raw')) {
			$query = 'LOAD <' . $uri . '> INTO <' . $uri . '>';
			$result = $store->query($query);

			if($store->getErrors() || $result['result']['t_count'] == 0) {
				if($forwardError)
					$this->_forward('error', 'api', null, array(
						'code' => 'LoadError',
						'message' => 'Could not find/load profile.'
					));
				return false;
			}

			$loaded = true;
		}

		// check if $uri is foaf:Person
		// otherwise try to find the correct uri
		$ask = $this->_queryPrefix .
			'ASK WHERE {' .
				'<' . $uri . '> rdf:type foaf:Person' .
			'}';
		if(!$store->query($ask, 'raw')) {
			$query = $this->_queryPrefix .
				'SELECT ?person WHERE {' .
					'<' . $uri . '> foaf:primaryTopic ?person .' .
				'}';
			$row = $store->query($query, 'row');
			
			if($store->getErrors() || !$row) {
				if($forwardError)
					$this->_forward('error', 'api', null, array(
						'code' => 'LoadError',
						'message' => 'Could not find/load profile.'
					));
				return false;
			}

			$identifier = $row['person'];
		}
		else
			$identifier = $uri;

		// if loaded we have to do some stuff
		if($loaded) {
			// load seeAlso properties
			// also consider sameAs properties
			$query = $this->_queryPrefix .
				'SELECT ?seealso WHERE {' . 
					'{ <' . $identifier . '> rdfs:seeAlso ?seealso . }' .
					' UNION ' .
					'{ <' . $identifier . '> owl:sameAs ?sameAs .' .
					'?sameAs rdfs:seeAlso ?seealso . }' .
				'} LIMIT ' . $this->_maxSeeAlso;
			$rows = $store->query($query, 'rows');
			
			// we ignore errors here
			// this is not as important to kill the whole process
			if(!$store->getErrors()) {
				foreach($rows as $row) {
					$query = 'LOAD <' . $row['seealso'] . '> INTO <' . $uri . '>';
					$store->query($query);
					if($store->getErrors())
						$store->errors = array();
				}
			}
			else
				$store->errors = array();

			// call inferencing script
			$this->inference($uri);
		}

		return $identifier;
	}

	/**
	 * Do some lightweight inferencing with sparql queries.
	 *
	 * @param string $graph The graph to do inferencing on.
	 * @return void
	 */
	protected function inference($graph)
	{
		// the max depth to inference
		$depthLimit = 10;

		$store = $this->getBrowserStore();
		$config = $this->getConfig();

		// subProperty inferencing
		for($d = 0; $d < $depthLimit; $d++) {
			$query = $this->_queryPrefix .
				'INSERT INTO <' . $graph . '> CONSTRUCT {' .
					'?s ?top ?o .' .
				'} WHERE {' .
					'GRAPH <' . $graph . '> {' .
						'?s ?prop ?o .' .
					'}' .
					'?prop rdfs:subPropertyOf ?top .' .
				'}';
			$result = $store->query($query);
			
			if($errors = $store->getErrors()) {
				if($config->misc->environment == 'development') {
					$die = '';
					for($i = 0; $i < count($errors); $i++) {
						$die .= $errors[$i];
						if($i < count($errors)-1)
							$die .= ' ';
					}
					die($die);
				}
				else
					$store->errors = array();
					
				break;
			}
			else if($result['result']['t_count'] == 0)
				break;
		}

		// foaf:surname to foaf:family_name inferencing
		// we use this as we only consider foaf:givenname and foaf:family_name inside origo
		// and unfortunately FOAF is heavily underspecified in case of names
		$query = $this->_queryPrefix .
			'INSERT INTO <' . $graph . '> CONSTRUCT {' .
				'?s foaf:family_name ?o .' .
			'} WHERE {' .
				'GRAPH <' . $graph . '> {' .
					'?s foaf:surname ?o' . 
				'}' .
			'}';
		$store->query($query);
		if($errors = $store->getErrors()) {
			if($config->misc->environment == 'development') {
				$die = '';
				for($i = 0; $i < count($errors); $i++) {
					$die .= $errors[$i];
					if($i < count($errors)-1)
						$die .= ' ';
				}
				die($die);
			}
			else
				$store->errors = array();
		}

		// foaf:firstName to foaf:givenname inferencing
		// we use this as we only consider foaf:givenname and foaf:family_name inside origo
		// and unfortunately FOAF is heavily underspecified in case of names
		$query = $this->_queryPrefix .
			'INSERT INTO <' . $graph . '> CONSTRUCT {' .
				'?s foaf:givenname ?o .' .
			'} WHERE {' .
				'GRAPH <' . $graph . '> {' .
					'?s foaf:firstName ?o' . 
				'}' .
			'}';
		$store->query($query);
		if($errors = $store->getErrors()) {
			if($config->misc->environment == 'development') {
				$die = '';
				for($i = 0; $i < count($errors); $i++) {
					$die .= $errors[$i];
					if($i < count($errors)-1)
						$die .= ' ';
				}
				die($die);
			}
			else
				$store->errors = array();
		}

		// owl:inverseOf inferencing
		$query = $this->_queryPrefix .
			'INSERT INTO <' . $graph . '> CONSTRUCT {' .
				'?o ?inv ?s .' .
			'} WHERE {' .
				'GRAPH <' . $graph . '> {' .
					'?s ?prop ?o .' .
				'}' .
				'?prop owl:inverseOf ?inv .' .
			'}';
		$result = $store->query($query);
		
		if($errors = $store->getErrors()) {
			if($config->misc->environment == 'development') {
				$die = '';
				for($i = 0; $i < count($errors); $i++) {
					$die .= $errors[$i];
					if($i < count($errors)-1)
						$die .= ' ';
				}
				die($die);
			}
			else
				$store->errors = array();
		}
	}

	/**
	 * This is a helper method to forward a triple store error.
	 *
	 * @param array $errors
	 */
	protected function forwardTripleStoreError($errors)
	{
		$first = true;
		$message = '';
		foreach($errors as $error) {
			if($first)
				$first = false;
			else
				$message .= ' ';
			$message .= $error;
		}

		$this->_forward('error', 'api', null, array(
			'code' => 'TripleStoreError',
			'message' => $message
		));
	}
}
